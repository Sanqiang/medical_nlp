package edu.pitt.medical_nlp;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.List;

import edu.pitt.medical_nlp.graph.Graph;
import edu.pitt.medical_nlp.graph.WordNode;
import edu.pitt.medical_nlp.utility.DependencyType;
import edu.pitt.medical_nlp.utility.Helper;
import edu.pitt.medical_nlp.utility.Module;
import edu.stanford.nlp.ling.HasWord;
import edu.stanford.nlp.ling.TaggedWord;
import edu.stanford.nlp.parser.nndep.DependencyParser;
import edu.stanford.nlp.tagger.maxent.MaxentTagger;
import edu.stanford.nlp.trees.GrammaticalStructure;
import edu.stanford.nlp.trees.GrammaticalStructure.Extras;
import edu.stanford.nlp.trees.TypedDependency;

public class PostProcess extends Process {
	public PostProcess() {
		super();
	}

	public void postProcessDocs(String filename) {
		boolean add_feature = true;
		try {
			postProcessSingleDocs();
			BufferedWriter writer = new BufferedWriter(new FileWriter(new File(filename)));

			for (List<List<WordNode>> record : _docs_processed) {
				for (List<WordNode> sentence : record) {
					for (HasWord word : sentence) {
						writer.write(word.word());
						writer.write(" ");
					}
				}
				if (add_feature) {
					for (String feature : add_features) {
						writer.write(feature);
						writer.write(" ");
					}
				}
				writer.write("\n");
			}
			writer.close();
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			System.out.println("Done!");
		}
	}

	public void postProcessSingleDocs() {
		MaxentTagger tagger = Module.getInst().getTagger();
		DependencyParser parser = Module.getInst().getDependencyParser();
		for (List<List<WordNode>> record : _docs_processed) {
			Graph graph = new Graph();
			int accumulate_idx = 0;
			for (List<WordNode> sentence : record) {
				List<TaggedWord> tagged = tagger.tagSentence(sentence);
				GrammaticalStructure gs = parser.predict(tagged);
				for (TypedDependency typed_dependence : gs.typedDependenciesCCprocessed(Extras.MAXIMAL)) {
					int idx_gov = accumulate_idx + typed_dependence.gov().index() - 1;
					int idx_dep = accumulate_idx + typed_dependence.dep().index() - 1;
					String lemma_gov = typed_dependence.gov().word(), lemma_dep = typed_dependence.dep().word();
					DependencyType dependency_type = Helper.mapRelationTypes(typed_dependence.reln().getShortName());
					switch (dependency_type) {
					case AdjectiveModifer:
						graph.createEdge(lemma_dep, lemma_gov, idx_dep, idx_gov, dependency_type);
						break;
					case Negative:
						graph.createEdge(lemma_dep, lemma_gov, idx_dep, idx_gov, dependency_type);
						break;
					case NominalSubject:
						graph.createEdge(lemma_gov, lemma_dep, idx_gov, idx_dep, dependency_type);
						break;
					case Compound:
						graph.createEdge(lemma_dep, lemma_gov, idx_dep, idx_gov, dependency_type);
						break;
					default:
						break;

					}
				}
				accumulate_idx += sentence.size();
			}
			add_features.addAll(graph.generateFeatures());
		}
	}
	
	public void postProcessSingleDocs2() {
		MaxentTagger tagger = Module.getInst().getTagger();
		DependencyParser parser = Module.getInst().getDependencyParser();
		for (List<List<WordNode>> record : _docs_processed) {
			Graph graph = new Graph();
			int accumulate_idx = 0;
			for (List<WordNode> sentence : record) {
				List<TaggedWord> tagged = tagger.tagSentence(sentence);
				GrammaticalStructure gs = parser.predict(tagged);
				for (TypedDependency typed_dependence : gs.typedDependenciesCCprocessed(Extras.MAXIMAL)) {
					int idx_gov = accumulate_idx + typed_dependence.gov().index() - 1;
					int idx_dep = accumulate_idx + typed_dependence.dep().index() - 1;
					String lemma_gov = typed_dependence.gov().word(), lemma_dep = typed_dependence.dep().word();
					DependencyType dependency_type = Helper.mapRelationTypes(typed_dependence.reln().getShortName());
					switch (dependency_type) {
					case AdjectiveModifer:
						graph.createEdge(lemma_dep, lemma_gov, idx_dep, idx_gov, dependency_type);
						break;
					case Negative:
						graph.createEdge(lemma_dep, lemma_gov, idx_dep, idx_gov, dependency_type);
						break;
					case NominalSubject:
						// graph.createEdge(lemma_dep, lemma_gov, idx_dep,
						// idx_gov,
						// dependency_type);
						graph.createEdge(lemma_gov, lemma_dep, idx_gov, idx_dep, dependency_type);
						break;
					case Compound:
						graph.createEdge(lemma_dep, lemma_gov, idx_dep, idx_gov, dependency_type);
						break;
					default:
						break;

					}
				}
				accumulate_idx += sentence.size();
			}
			add_features.addAll(graph.generateFeatures());
		}
	}
}
